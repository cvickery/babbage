<?php
  if (array_key_exists("HTTP_ACCEPT", $_SERVER) &&
      stristr($_SERVER["HTTP_ACCEPT"], "application/xhtml+xml") )
  {
    header("Content-type: application/xhtml+xml");
    print("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n");
  }
  else
  {
    header("Content-type: text/html; charset=utf-8");
  }
 ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>

<title>Servomotor Controller</title>


<link rel="shortcut icon" href="/favicon.ico" />
    <link rel="stylesheet"
          type="text/css"
          media="all"
          href="/courses/css/style-all.css" />
    <link rel="stylesheet"
          type="text/css"
          media="screen"
          href="/courses/css/style-screen.css" />
    <link rel="stylesheet"
          type="text/css"
          media="print"
          href="/courses/css/style-print.css" />

    <style type="text/css">
      td { text-align: center; }
      .highlight { background-color: #cfc; color: #000; }
      .aside { font-size: 0.85em; font-style: italic; }
      #sevenseg2msec { width: 50% }
    </style>
</head>

<body>

  <div id="header">
    <h1>CS-345/780 Laboratory 3</h1>
    <h2>Servomotor Controller</h2>
  </div>
  <div id="content">
    <h2>Introduction</h2>
    <div class="whitebox">

      <p>In this laboratory, you will explore direct interaction between the
      FPGA and the &ldquo;outside world.&rdquo; Instead of using the macros
      in the Platform Abstraction Layer (PAL) to access the input and output
      devices, this project will show you the nitty-gritty of actually
      manipulating the voltage values on the FPGA pins.</p>

      <p>As you know, the Simulation design flow allows you to debug your
      code both by monitoring its external behavior on the PAL Virtual
      Console, and by examining its internal state using the DK simulator.
      But for this project, you are using a device that is not supported by
      the PAL Virtual Console, namely a small servomotor that is controlled
      using <span class="techTerm" title="The width of a pulse controls the
      rotation of the motor">pulse width modulation</span> (PWM).  Not only
      do you not have the PAL Virtual Console for feedback, but you also
      have to deal with the fact that the DK simulator does not provide the
      real-time timing information you need to check whether your pulse
      width modulation code is actually modulating pulse widths correctly. 
      So this project introduces you to the use of two tools for testing
      (and debugging) the timing of your design.  One is an extension to the
      DK simulation software, called the <span class="programName">Waveform
      Analyzer</span>.  In addition, you will practice using an oscilloscope
      to check the actual waveforms generated by your design.  Finally, you
      will connect a servomotor to the RC200E and verify that your program
      actually does control the motor correctly.</p>

    </div>

    <h2>Controller Description</h2>
    <div class="whitebox">

      <p>The servomotor you will be controlling, the Futaba S3003, is
      normally used to operate radio controlled model airplanes, cars, or
      boats.  Normally, when it receives pulses of one width, the motor
      shaft rotates clockwise about a quarter turn and when it receives
      pulses of a different width, it rotates in the opposite direction.  It
      has an internal circuit that senses its own displacement clockwise or
      counterclockwise and returns the motor to its &ldquo;neutral&rdquo;
      position when no pulses are applied.  This design is great for
      steering planes, cars, and boats, but cannot be used to make cars or
      robots move &mdash; at least not very far.  So a popular modification
      is to modify the motor mechanically to remove the stop that prevents
      360&deg; rotation, and the linkage between the shaft position sensor
      (a potentiometer) and the shaft.  The motors in the lab have been
      modified this way.</p>

      <p>The servomotor has three wires connected to it: a black one that
      goes to ground, a red one that connects to a positive voltage betwen
      4.8 and 6.0 volts, and a white one that receives control pulses.  We
      have rigged connectors so the motors can be connected to the 50-pin
      &ldquo;expansion header&rdquo; on the side of the RC200. Pin 46 of the
      expansion header provides +5VDC, eight pins supply ground, and 34 of
      the pins are connected to the I/O pins of the FPGA.  When you plug the
      motor connector into the expansion header, the red wire goes to Pin
      46, the black wire goes to Pin 50 (one of the ground connections), and
      the white wire goes to Pin 38, which is connected to I/O pin
      &ldquo;V2&rdquo; of the FPGA.</p>

      <p>To make the motor work, it must receive a 50 Hz pulse train.  If
      the width of the pulses is 1 msec the motor rotates in one direction;
      if the width of the pulses is 2 msec, the motor rotates in the
      opposite direction, and if the width of the pulses is 1.5 msec, the
      motor stops rotating.  When your controller is finished, it will
      generate a continuous 50 Hz pulse stream on FPGA Pin V2.  The two
      pushbuttons on the side of the RC200E will modify the width of the
      pulses as follows:  initially, the pulse width will be 1.5 msec;
      pressing button 0 will increment or decrement the pulse width by 10
      &micro;sec, and pressing button 1 will control whether button 0 adds
      to or subtracts from the pulse width.  By providing such fine control
      over the pulse widths, you should be able to control not only the
      direction of rotation, but also the speed.</p>

    </div>

    <h2>Procedure</h2>
    <div class="whitebox">
      <ol>

        <li>

          <h5>Start a new project.</h5> <p class="runin">Create a new
          project named &ldquo;Motor_Controller&rdquo; for this laboratory.
          Configure it for Simulation and EDIF in the usual way, with the
          following clock values:</p>

            <p>Use 1 MHz as the target clock rate for the Debug build
            configuration and 50 MHz as the target clock rate for EDIF. 
            Note that the target rate for simulation is not totally
            arbitrary; correct operation of the Waveform Analyzer program
            (see below) will depend on this value matching the setup
            parameters specified here.  You will need some conditional
            compilation for this assignment, so you find it easier to use
            <span class="codeSnippet">#define</span> statements to set the
            clock values rather than using the Preprocessor tab in the
            project settings panel.  Use Laboratory 2 as a model for this.</p>

        </li>

        <li>

          <h5>Add <span class="functionName">usecDelay()</span> to
          your <span class="fileName">delayProcs</span> library.</h5>
          <p class="runin">You need finer timing control for this
          project than your <span
          class="functionName">msecDelay()</span> provides.  Update
          <span class="fileName">delayProcs.hch</span> to include the
          function prototype for a macro proc that delays for a
          specified number of microseconds (&micro;sec) rather than
          milliseconds.  Add a second Handel-C source file to the
          library project with your new <span
          class="functionName">usecDelay()</span> procedure in it.</p>

        </li>

        <li>

          <h5>Construct a modified version of Laboratory 2</h5> <p
          class="runin">Superficially, this project starts out very
          similarly to Laboratory 2 because we will use the two pushbuttons
          to control the operation of a two digit counter.  But in this
          project the buttons will be used to control the width of the
          pulses going to the servomotor and the counter will show how wide
          those pulses are.  Here is how the values displayed on the seven
          segment displays will ultimately map to pulse widths:</p>

          <table id="sevenseg2msec">
            <col width="1" />
            <col width="1" />
            <tr>
              <th>Display</th><th>Pulse Width in Milliseconds</th>
            </tr>
            <tr>
              <td>00</td><td>1.<span class="highlight">00</span>0</td>
            </tr>
            <tr>
              <td>01</td><td>1.<span class="highlight">01</span>0</td>
            </tr>
            <tr>
              <td>50</td><td>1.<span class="highlight">50</span>0</td>
            </tr>
            <tr>
              <td>99</td><td>1.<span class="highlight">99</span>0</td>
            </tr>
          </table>

          <p>We want to use the two buttons to change the pulse width so you
          can see the effect on the motor.  Here is a suggested way to do
          that: one button toggles whether the display steps upward or
          downward when it changes, and the other button controls whether
          the display is actively stepping (while the button is pressed) or
          not (while the button is not pressed).  Compared to Lab 2, the
          first button works like the <span class="variableName">run</span>
          button, and might meaningfully be called &ldquo;up/down&rdquo; for
          this project.  The second button works like the <span
          class="variableName">fast</span> button, and might be called
          &ldquo;step/stop&rdquo; for this project.  Here are some features
          to note:</p>

          <ul>

            <li>Instead of starting at 00 the counter should start at 50,
            which corresponds to 1.5 msec, the neutral point where the motor
            stops.</li>
            
            <li>Instead of changing once a second or ten times a second, it
            will be convenient (for the user) if the value changes at some
            rate in between that range when stepping through the different
            values.  Something in the range of 2-5 steps per second would be
            good; try to design your code so that this is an easy parameter
            to &ldquo;tweak&rdquo;.  If you want a challenge, design it so
            the stepping rate is slow when the <span
            class="variableName">step/stop</span> button is first pressed,
            and then speeds up if the button is held on for a while.</li>

            <li>When stepping, have the direction automatically toggle when
            either limit is reached.  That is, when stepping upward, switch
            to downward when the value 99 is reached and when stepping
            downward switch to upward when the value 00 is reached.</li>

          </ul>

          <p>Make sure your code works correctly at this point for both
          simulation and on the RC200E.</p>

        </li>
        
        <li>

          <h5>Simulate code that outputs to a pin.</h5> <p
          class="runin">Define a 1-bit unsigned integer named <span
          class="variableName">controlPin</span>, and another variable named
          <span class="variableName">pulseWidth</span> that can hold a value
          that ranges from 100 to 200. The former will output the pulses to
          the motor, and the latter will tell how wide each pulse is, in
          hundredth of a millisecond (10 &micro;sec) units. That is, a <span
          class="variableName">pulseWidth</span> value of 100 will
          correspond to 1 msec, 150 will be 1.5 msec, and 199 will be 1.99
          msec. (Our design doesn&rsquo;t allow the value to reach a full 2
          msec.)  Set up your code so that <span
          class="variableName">pulseWidth</span> and the seven segment
          displays are synchronized. when the seven segment displays show
          00, <span class="variableName">pulseWidth</span> should be 100, 50
          on the display corresponds to a <span
          class="variableName">pulseWidth</span> of 150, and 99 on the
          display corresponds to a <span
          class="variableName">pulseWidth</span> of 199.</p>

          <p class="standoutBox"><strong>Avoid using division!</strong> 
          Avoid the temptation to use a single register to hold the value of
          <span class="variableName">pulseWidth</span> and to use <span
          class="functionName">divide</span> and  <span
          class="functionName">mod</span> operators (<span
          class="keyWord">/</span> and <span class="keyWord">%</span>) to
          break it into the <span class="variableName">tens</span> and <span
          class="variableName">units</span> decimal digits.  <span
          class="aside">[This note is left over from a previous semester
          where students did not do the two digit timer project.  It
          wouldn&rsquo;t make sense for you to set up the relationship
          between <span class="variableName">pulseWidth</span>, <span
          class="variableName">units</span>, and <span
          class="variableName">tens </span> this way but I&rsquo;m leaving
          this note in because I want to make the point about division
          anyway.]</span> Using division and modulo would work, but the
          design will be bigger and take longer to build than if you avoid
          these operations.  Multiplication, on the other hand, can be done
          relatively efficiently on the FPGA, especially if the widths of
          the operands are 18 bits or less.</p>
          
          <p>To set up the 50 Hz pulse train, write two parallel endless
          loops, and connect them by a 0-bit wide channel (<span
          class="keyWord">chan</span>).  The Handel-C language manual
          describes channels: they are used to pass information from one
          thread to another with automatic synchronization so that the
          actual transfer takes place on the same clock cycle regardless of
          whether the reading thread or the writing thread gets to its side
          of the channel first.  We need the synchronization feature but not
          the actual information-exchange feature, so you can declare 0-bit
          wide variables (no information) that get written to and read from
          the channel.  The first loop writes to the channel at a 50 Hz
          rate.  The second loop, reads from the channel, sets <span
          class="variableName">controlPin</span> to 1, delays the number of
          microseconds given by the current value of <span
          class="variableName">pulseWidth</span>, sets <span
          class="variableName">controlPin</span> to zero, and then waits at
          the channel again.  Implicit in this algorithm is the fact that
          the pulse widths will always be less than the period of the 50 Hz
          pulse train, so the 50 Hz thread will never block waiting for the
          pulse generator thread to read from the channel.</p>

          <p class="standoutBox">Remember, <span
          class="functionName">usecDelay()</span> is a macro that gets
          expanded at compile time: the values passed as arguments must be
          constants known at compile time, not variables.  You cannot simply
          pass <span class="codeSegment">(1000 + pulseWidth * 10)</span> as
          the number of microseconds to delay.  Rather, you need a loop that
          calls <span class="codeSnippet">usecDelay(ClockRate, 10)</span>
          the appropriate number of times.</p>

          <p>Now you need to add code that connects <span
          class="variableName">controlPin</span> to the simulator. Look at
          the Waveform Anlyzer manual in the <span
          class="directoryName">Celoxica/DK/Documentation</span> directory.
          The Waveform Analyzier can do two different things: (1) show the
          timing of your program&rsquo;s outputs (what we want) and (2)
          generate waveforms for input to your program (not of interest to
          us for this project). So, you are interested in only Chapter 1 of
          the manual for this assignment, and need to read just the first
          ten pages before continuing.</p>

          <hr style="width:30%; margin: auto;" />

          <p>Using the Waveform Analyzer manual as a guide, set up
          your code so you can monitor the value of <span
          class="variableName">controlPin</span>.  You will have to
          synchronize the DK simulator&rsquo;clock with the Waveform
          Analyzer&rsquo;s clock, and you will have to connect the
          value of <span class="variableName">controlPin</span> to the
          Waveform Analyzer&rsquo;s &ldquo;terminal&rdquo;
          interface.</p>

          <div class="codeBlock">
  #ifdef USE_SIM
  #define PAL_ACTUAL_CLOCK_RATE 1000000
  set clock = external "P1"
    with
    {
      extlib  = "DKSync.dll",
      extinst = "1000",       // Period of 1MHz simulated clock in nsec
      extfunc = "DKSyncGetSet"
    };
  interface bus_out() motor( unsigned 1 out = controlPin )
    with
    {
      extlib  = "DKConnect.dll",
      extinst = "t(1)",
      extfunc = "DKConnectGetSet"
     };
  #else
  #define PAL_TARGET_CLOCK_RATE 50000000
  #endif
  
  #include &lt;pal_master.hch&gt;
  macro expr ClockRate = PAL_ACTUAL_CLOCK_RATE;
          </div>

        <p>I apologize for giving you so much code!<br />Be sure to study it
        rather than just cutting and pasting blindly.</p>

        <p>When you set up your Waveform Analyzer trace window, be sure to
        specify the correct clock period (in nsec), and set the
        &ldquo;Default No. Points&rdquo; so that one sweep across the window
        will correspond to exactly one period of the 50 Hz pulse train.  The
        idea is that you want each pulse to display in the same place in the
        window on each sweep.  (I&rsquo;m omitting the details on this; try
        to figure the numbers out yourself.)</p>

        <p>When you have this step working correctly, you should be able to
        observe the PAL Virtual Console and the Waveform Analyzer window at
        the same time.  Clicking on buttons on the virtual console should
        control the value displayed on the seven segment displays, and you
        should be able to see the effect on the waveform being traced out in
        the Waveform Analyzer window.  Make sure the pulses don&rsquo;t
        drift across the window, even a little bit.  If they do move it
        means the 50 Hz thread is not taking exactly 1/50" per cycle.  Use
        Waveform Analyzer cursors to verify that the pulses are of the
        correct width.  Because the simulated clock has a period of one
        &micro;sec, you will be able to detect any inaccuracy in either your
        pulse width thread (wrong number of calls to <span
        class="functionName">usecDelay()</span>) and/or the implementation
        of <span class="functionName">usecDelay()</span> itself.</p>

        <p class="standoutBox">Because of the pixel resolution of the
        monitor, you might not be able to get the cursors to line up exactly
        with the edges of the pulses and the pulse width measurements may be
        off by a small amount as a result.  However, (1) you should be able
        to see that the pulse widths change by exactly 100 &micro;sec for
        each step up or down, and (2) the pulses should always start at
        exactly the same point in the waveform window and not drift left or
        right.</p>

        </li>

        <li> <h5>Familiarize yourself with the oscilloscopes
        used in the lab.</h5> <p class="runin"> Look through
        the Tektronix <a
        href="../XYZs_of_Oscilloscopes.pdf">&ldquo;XYZ&rsquo;s
        of Oscilloscopes&rdquo; primer</a>.  You will be
        working with a Digital Storage Oscilloscope (DSO) to
        look at waveforms output by the FPGA to the
        expansion header pins on the side of the RC200E.
        Look at pages 13-14 for a description of DSOs, pages
        18-32 for a description of the various controls on
        an oscilloscope, and pages 46-47 on probe
        compensation.</p>

          <p>Set up an oscilloscope and compensate the probe.</p>

        </li>
        <li>

          <h5>Configure for EDIF with <span
          class="variableName">controlPin</span> connected to an expansion
          header pin, and monitor the pin using the oscilloscope.</h5> <p
          class="runin">Use conditional compilation to compile the following
          interface definition if <span class="codeSnippet">USE_SIM</span>
          is <em>not</em> defined:</p>

          <div class="codeBlock">
interface bus_out() motor( unsigned 1 out = controlPin )
  with
  {
    data  = { "V2" }
  };
          </div>

          <p><span class="codeSnippet">V2</span> is the name of the
          pin on the FPGA that is connected to pin number 38 on the
          expansion header.  (The manual that documents this is in
          <span class="directoryName">
          &hellip;\Celoxica\PDK\Documentation\PSL\RC20x\Manuals</span>.)</p>

          <p>Carefully connect the tip of the oscilloscope probe to pin 38
          of the expansion header.  It&rsquo;s the sixth pin from the left
          on the bottom row; the second one past the empty spot with 42
          printed on the circuit board.  You will probably get a perfectly
          good signal with the probe&rsquo;s ground clip disconnected, so
          don&rsquo;t worry about connecting it.  Download your program to
          the FPGA and perform the following exercises with the
          oscilloscope:</p>

          <p>First press the &ldquo;Auto Set&rdquo; button to have the
          oscilloscope detect your signal automatically.  If
          necessary, use the trigger menu to select positive edge
          triggering from channel 1 and use the channel 1 menu to
          select DC coupling.  Bandwidth limiting should be off, volts
          per division can be either coarse or fine, the probe should
          auto-detect 10X attenuation; if not, set it to 10X and be
          sure the switch on the side of the probe is set to 10X
          too.</p>

          <ol>

            <li>Verify that your pulse train is operating at 50 Hz.</li>

            <li>Verify that the initial pulse width is exactly 1.5
            msec.  Use the &ldquo;Measure&rdquo; and
            &ldquo;Cursor&rdquo; buttons to measure the pulse
            width.</li>

            <li>Verify that the pulse width changes by 10 &micro;sec each
            time you increment or decrement the seven segment display value
            by one.</li>

          </ol>

        </li>
        <li style="margin-top: 1em">

          <h5>Connect a servomotor to the RC200E and verify that your
          controller actually works.</h5><p class="runin">If you are
          sure the pulse parameters are correct on the oscilloscope
          but the motor &ldquo;creeps&rdquo; in one direction or the
          other when you first start your program, there is a
          screwdriver adjustment I can make that will stop it.</p>

        </li>

      </ol>

    </div>


  </div>
  <div id="footer">
  <hr />
    <p class="links">
      <a href="/">Vickery Home</a>&nbsp;-
      <a href=".">CS-345/780 Home</a><br />
      <a href="http://validator.w3.org/check?uri=referer">
      XHTML</a>&nbsp;-&nbsp;
      <a href="http://jigsaw.w3.org/css-validator/check/referer">
      CSS</a>    </p>
    <p><em>Last updated
      <?php echo date("Y-m-d", filemtime($_SERVER['SCRIPT_FILENAME']));
        ?>.</em>    </p>
</div>
  </body>
</html>
