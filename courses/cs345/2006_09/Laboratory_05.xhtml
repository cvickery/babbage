<?php
  if (array_key_exists("HTTP_ACCEPT", $_SERVER) &&
      stristr($_SERVER["HTTP_ACCEPT"], "application/xhtml+xml") )
  {
    header("Content-type: application/xhtml+xml");
    print("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n");
  }
  else
  {
    header("Content-type: text/html; charset=utf-8");
  }
 ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>

<title>CS-345/780 Laboratory V</title>


<link rel="shortcut icon" href="/favicon.ico" />
    <link rel="stylesheet"
          type="text/css"
          media="all"
          href="/courses/css/style-all.css" />
    <link rel="stylesheet"
          type="text/css"
          media="screen"
          href="/courses/css/style-screen.css" />
    <link rel="stylesheet"
          type="text/css"
          media="print"
          href="/courses/css/style-print.css" />
</head>

<body>

  <div id="header">
    <h1>CS-345/780 Laboratory V</h1>
    <h2>Servomotor Controller</h2>
  </div>
  <div id="content">
    <h2>Introduction</h2>
    <div class="whitebox">
      <p>In this laboratory, you will explore direct interaction
      between the FPGA and the &ldquo;outside world.&rdquo; Until now,
      you performed all input and output operations using the macros
      in the Platform Abstraction Layer (PAL), which sheilded you from
      the nitty-gritty of actually manipulating the voltage values on
      the FPGA pins.  With this project your PAL-provided innocence
      expires.</p>

      <p>As you know, the Simulation design flow allows you to debug your
      code both by monitoring its external behavior on the PAL Virtual
      Console, and by examining its internal state using the DK simulator.
      But for this project, you are using a device that is not supported by
      the PAL Virtual Console, namely a small servomotor that is controlled
      using pulse width modulation (PWM).  Not only do you not have the PAL
      Virtual Console for feedback, but you also have to deal with the fact
      that the DK simulator does not provide the real-time timing
      information you need to check whether your pulse width modulation code
      is actually modulating pulse widths correctly.  So this project
      introduces you to the use of two tools for testing (and debugging) the
      timing of your design.  One is an extension to the DK simulation
      software, called the <span class="programName">Waveform
      Analyzer</span>.  In addition, you will practice using an oscilloscope
      to check the actual waveforms generated by your design.  Finally, you
      will connect a servomotor to the RC200E and verify that your program
      actually does control the motor correctly.</p>
    </div>

    <h2>Controller Description</h2>
    <div class="whitebox">
      <p>The servomotor you will be controlling, the Futaba S3003, is
      normally used to operate radio controlled model airplanes, cars, or
      boats.  Normally, when it receives pulses of one width, the motor
      shaft rotates clockwise about a quarter turn and when it receives
      pulses of a different width, it rotates in the opposite direction.  It
      has an internal circuit that senses its own displacement clockwise or
      counterclockwise and returns the motor to its &ldquo;neutral&rdquo;
      position when no pulses are applied.  This design is great for
      steering planes, cars, and boats, but cannot be used to make cars or
      robots move &mdash; at least not very far.  So a popular modification
      is to modify the motor mechanically to remove the stop that prevents
      360&deg; rotation, and the linkage between the shaft position sensor
      (a potentiometer) and the shaft.  The motors in the lab have been
      modified this way.</p>

      <p>The servomotor has three wires connected to it: a black one that
      goes to ground, a red one that connects to a positive voltage betwen
      4.8 and 6.0 volts, and a white one that receives control pulses.  We
      have rigged connectors so the motors can be connected to the 50-pin
      &ldquo;expansion header&rdquo; on the side of the RC200. Pin 46 of the
      expansion header provides +5VDC, eight pins supply ground, and 34 of
      the pins are connected to the I/O pins of the FPGA.  When you plug the
      motor connector into the expansion header, the red wire goes to Pin
      46, the black wire goes to Pin 50 (one of the ground connections), and
      the white wire goes to Pin 38, which is connected to I/O pin
      &ldquo;V2&rdquo; of the FPGA.</p>

      <p>To make the motor work, it must receive a 50 Hz pulse train.  If
      the width of the pulses is 1 msec the motor rotates in one direction;
      if the width of the pulses is 2 msec, the motor rotates in the
      opposite direction, and if the width of the pulses is 1.5 msec, the
      motor stops rotating.  When your controller is finished, it will
      generate a continuous 50 Hz pulse stream on FPGA Pin M3.  The two
      pushbuttons on the side of the RC200E will modify the width of the
      pulses as follows:  initially, the pulse width will be 1.5 msec;
      pressing button 0 will increment or decrement the pulse width by 10
      &micro;sec, and pressing button 1 will control whether button 0 adds
      to or subtracts from the pulse width.  By providing such fine control
      over the pulse widths, you should be able to control not only the
      direction of rotation, but also the speed.</p>
    </div>

    <h2>Procedure</h2>
    <div class="whitebox">
      <ol>

        <li>

          <h5>Start a new project.</h5> <p class="runin">Create a new
          project named &ldquo;Motor_Controller&rdquo; for this laboratory.
          Configure it for Simulation and EDIF in the usual way, with the
          following differences:</p>
          <ol>

            <li>Instead of defining <span
            class="codeSnippet">PAL_TARGET_CLOCK_RATE</span> with a
            <span class="codeSnippet">#define</span> preprocessor
            directive, do it in the Preprocessor tab of the Project
            Settings panel.  Where you specify <span
            class="codeSnippet">USE_xxx</span>, add <span
            class="codeSnippet">PAL_TARGET_CLOCK_RATE=50000000</span>
            for the EDIF configuration.  But for Simulation, specify a
            1 MHz clock instead of 50 MHz.  The reason for using such
            a low clock rate for simulation is to help make using the
            Waveform Analyzer a bit easier as discussed below.  By
            specifying the two different clock rates here, you avoid
            the need for conditional compilation in your source code
            later.</li>

            <li>On the same Preprocessor tab, put the relative path to
            the directory containing your  <span
            class="fileName">delayProcs.hch</span> file in the
            &ldquo;Additional Include Directories&rdquo; box.  Now you
            will be able to include your header file using angle
            brackets instead of quotes, and won&rsquo;t have to type
            in the path to the directory in your code either</li>

            <li>Finally, on the Linker tab, put the relative pathname
            to your library file&rsquo;s directory in the Additional
            Library Path box, and remove the path component from the
            library name.</li>

          </ol>

          <p>The previous assignment should have used the second two
          items above, but it&rsquo;s not too late to make things
          right!</p>

        </li>

        <li>

          <h5>Add <span class="functionName">usecDelay()</span> to
          your <span class="fileName">delayProcs</span> library.</h5>
          <p class="runin">You need finer timing control for this
          project than your <span
          class="functionName">msecDelay()</span> provides.  Update
          <span class="fileName">delayProcs.hch</span> to include the
          function prototype for a macro proc that delays for a
          specified number of microseconds (&micro;sec) rather than
          milliseconds.  Add a second Handel-C source file to the
          library project with your new <span
          class="functionName">usecDelay()</span> procedure in it.</p>

          <h5>Optional:</h5><p class="runin">Use a Handel-C <span
          class="functionName">assert()</span> statement to generate
          the width of the counter register.  If the number of ticks
          is not greater than 0, the assertion should fail, reporting
          the delay interval and clock speed passed as parameters.
          Test the assertion by calling the macro with a short
          interval and slow clock speed.</p>

        </li>

        <li>

          <h5>Use the buttons to change values and seven segment
          displays to show them.</h5> <p class="runin">Create a source
          file for the laboratory named <span
          class="fileName">motor_controller.hcc</span> if you have not
          done so already.  Write code so that pressing button 0 makes
          the seven segment displays count upward from 00 to 99 in
          decimal. Think in terms of two Binary Coded Decimal (BCD)
          digits. Each button press and release must make the counter
          increment by exactly one; this is an exercise in
          &ldquo;debouncing&rdquo; the button, as described in class.
          You may cause the count to increment on either the press or
          the release, but not both. Now make it so that pressing
          button 1 makes the displays count downwards instead of
          upwards. Turn on the right decimal point when counting up
          and turn it off when counting down. Automatically switch
          directions if the user tries to count up beyond 99 or down
          below 00.</p>

          <p>Even if the code works properly on the RC200E, also make
          sure it simulates correctly. You will be using the simulator
          explcitly below, so this part has to work correctly both
          ways from the beginning.</p>

          <p><strong>Do not use division!</strong>  Avoid the
          temptation to use a single register to hold the value of the
          counter and to use <span class="functionName">divide</span>
          and  <span class="functionName">mod</span> to break it into
          decimal digits.  Or don&rsquo;t believe me, try it, and see
          how much of the FPGA your design uses and how long it takes
          to build!</p>

        </li>
        
        <li>

          <h5>Simulate code that outputs to a pin.</h5> <p
          class="runin">Define a 1-bit unsigned integer named <span
          class="variableName">controlPin</span>, and another variable
          named <span class="variableName">pulseWidth</span> that can
          hold a value that ranges from 100 to 200. The former will
          output the pulses to the motor, and the latter will tell how
          wide each pulse is, in hundredths of a millisecond. That
          is, a <span class="variableName">pulseWidth</span> value of
          100 will be 1 msec, 150 will be 1.5 msec, and 200 will be 2
          msec. Add logic to your code so that <span
          class="variableName">pulseWidth</span> and the seven
          segment displays are synchronized. when the seven segment
          displays show 00, <span
          class="variableName">pulseWidth</span> should be 100, 50 on
          the display corresponds to a <span
          class="variableName">pulseWidth</span> of 150, and 99 on the
          display corresponds to a <span
          class="variableName">pulseWidth</span> of 199.</p>

          <p>Write two parallel endless loops, and connect them by a
          0-bit wide channel.  The first loop is to write to the
          channel at a 50 Hz rate.  The second loop, reads from the
          channel, sets <span class="variableName">controlPin</span>
          to 1, delays the number of microseconds given by the current
          value of <span class="variableName">pulseWidth</span>, sets
          <span class="variableName">controlPin</span> to zero, and
          waits at the channel again.</p>

          <p>Now you need to add code that connects <span
          class="variableName">controlPin</span> to the simulator.
          Look at the Waveform Anlyzer manual in the <span
          class="directoryName">Celoxica/DK/Documentation</span>
          directory. The Waveform Analyzier can both show the timing
          ouf your program&rsquo;s outputs (what we want) and generate
          waveforms for input to your program (not of interest to us
          for this project). So, you are interested in only Chapter 1
          of the manual for this assignment, and need to read just the
          first ten pages before continuing.</p>

          <hr style="width:30%; margin: auto;" />

          <p>Using the Waveform Analyzer manual as a guide, set up
          your code so you can monitor the value of <span
          class="variableName">controlPin</span>.  You will have to
          synchronize the DK simulator&rsquo;clock with the Waveform
          Analyzer&rsquo;s clock, and you will have to connect the
          value of <span class="variableName">controlPin</span> to the
          Waveform Analyzer&rsquo;s &ldquo;terminal&rdquo;
          interface.</p>

          <p>Managing the clock is tricky.  If you just use <span
          class="fileName">pal_master.hch</span> to generate the value
          of <span class="codeSnippet">PAL_ACTUAL_CLOCK_RATE</span>
          from <span class="codeSnippet">PAL_TARGET_CLOCK_RATE</span>,
          you will get multiple clocks defined for your code: one
          <span class="codeSnippet">set clock</span> in <span
          class="fileName">pal_master.hch</span>, and a second one
          that you will need to code following the guidelines of the
          Waveform Analyzer manual.  The trick is to use conditional
          compilation and to include pal_master <em>after</em> you
          define PAL_ACTUAL_CLOCK_RATE explicitly yourself:</p>

          <div class="codeBlock">
  #ifdef USE_SIM
  set clock = external "P1"
    with
    {
      extlib  = "DKSync.dll",
      extinst = "1000",       // Period of 1MHz simulated clock in nsec
      extfunc = "DKSyncGetSet"
    };
  #define PAL_ACTUAL_CLOCK_RATE PAL_TARGET_CLOCK_RATE
  interface bus_out() motor( unsigned 1 out = controlPin )
    with
    {
      extlib  = "DKConnect.dll",
      extinst = "t(1)",
      extfunc = "DKConnectGetSet"
     };
  #endif
  #include &lt;pal_master.hch&gt;
  #ifndef PAL_ACTUAL_CLOCK_RATE
  #error "No clock rate specified!"
  #else
  macro expr clockRate = PAL_ACTUAL_CLOCK_RATE;
  #endif
          </div>

        <p>I apologize for giving you so much code!<br />Be sure to study it
        rather than just cutting and pasting blindly.</p>

        <p>When you set up your Waveform Analyzer trace window, be sure to
        specify the correct clock period (in nsec), and set the
        &ldquo;Default No. Points&rdquo; so that one sweep across the window
        will correspond to exactly one period of the 50 Hz pulse train.  The
        idea is that you want each pulse to display in the same place in the
        window on each sweep.</p>

        <p>When you have this step working correctly, you should be able to
        observe the PAL Virtual Console and the Waveform Analyzer window at
        the same time.  Clicking on Button 0 on the virtual console should
        change the value displayed on the seven segment displays, and you
        should be able to see the effect on the waveform being traced out in
        the Waveform Analyzer window.  Use Waveform Analyzer cursors to
        verify that the pulses are of the correct width.</p>

        </li>

        <li>
          <h5>Familiarize yourself with the oscilloscopes used in the
          lab.</h5> <p class="runin"> Look through the Tektronix
          &ldquo;XYZ&rsquo;s of Oscilloscopes&rdquo; primer provided
          to you.  You will be working with a Digital Storage
          Oscilloscope (DSO) to look at waveforms output by the FPGA to the
          expansion header pins on the side of the RC200E.  Look at
          pages 13-14 for a description of DSOs, pages 18-32 for a
          description of the various controls on an oscilloscope, and
          pages 46-47 on probe compensation.</p>

          <p>Set up an oscilloscope and compensate the probe.</p>

        </li>
        <li>

          <h5>Configure for EDIF with <span
          class="variableName">controlPin</span> connected to an
          expansion header pin, and monitor the pin using the
          oscilloscope.</h5> <p class="runin">Use conditional
          compilation to compile the following interface definition if
          <span class="codeSnippet">USE_RC200E</span> is defined:</p>

          <div class="codeBlock">
interface bus_out() motor( unsigned 1 out = controlPin )
  with
  {
    data  = { "V2" }
  };
          </div>

          <p><span class="codeSnippet">V2</span> is the name of the
          pin on the FPGA that is connected to pin number 38 on the
          expansion header.  (The manual that documents this is in
          <span class="directoryName">
          &hellip;\Celoxica\PDK\Documentation\PSL\RC20x\Manuals</span>.)</p>

          <p>Carefully connect the tip of the oscilloscope probe to
          pin 38 of the expansion header.  It&rsquo;s the sixth pin
          from the left on the bottom row; the second one past the
          empty spot with 42 printed on the circuit board.  You will
          probably get a perfectly good signal with the ground clip
          disconnected.  Download your program to the FPGA and perform
          the following exercises with the oscilloscope:</p>

          <p>First press the &ldquo;Auto Set&rdquo; button to have the
          oscilloscope detect your signal automatically.  If
          necessary, use the trigger menu to select positive edge
          triggering from channel 1 and use the channel 1 menu to
          select DC coupling.  Bandwidth limiting should be off, volts
          per division can be either coarse or fine, the probe should
          auto-detect 10X attenuation; if not, set it to 10X and be
          sure the switch on the side of the probe is set to 10X
          too.</p>

          <ol>

            <li>Verify that your pulse train is operating at 50 Hz.</li>

            <li>Verify that the initial pulse width is exactly 1.5
            msec.  Use the &ldquo;Measure&rdquo; and
            &ldquo;Cursor&rdquo; buttons to measure the pulse
            width.</li>

            <li>Verify that the pulse width changes by 10 &micro;sec
            each time you press Button 0.</li>

          </ol>

        </li>
        <li style="margin-top: 1em">

          <h5>Connect a servomotor to the RC200E and verify that your
          controller actually works.</h5><p class="runin">If you are
          sure the pulse parameters are correct on the oscilloscope
          but the motor &ldquo;creeps&rdquo; in one direction or the
          other when you first start your program, there is a
          screwdriver adjustment I can make that will stop it.</p>

        </li>

      </ol>

    </div>


  </div>
  <div id="footer">
  <hr />
    <p class="links">
      <a href="/">Vickery Home</a>&nbsp;-&nbsp;
      <a href="http://validator.w3.org/check?uri=referer">
      XHTML</a>&nbsp;-&nbsp;
      <a href="http://jigsaw.w3.org/css-validator/check/referer">
      CSS</a>    </p>
    <p><em>Last updated
      <?php echo date("Y-m-d", filemtime($_SERVER['SCRIPT_FILENAME']));
        ?>.</em>    </p>
</div>
  </body>
</html>
