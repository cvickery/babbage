{\rtf1\adeflang1025\ansi\ansicpg1252\uc1\adeff0\deff0\stshfdbch0\stshfloch0\stshfhich0\stshfbi0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}{\f37\froman\fcharset238\fprq2 Times New Roman CE;}
{\f38\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f40\froman\fcharset161\fprq2 Times New Roman Greek;}{\f41\froman\fcharset162\fprq2 Times New Roman Tur;}{\f42\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}
{\f43\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f44\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f45\froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\f47\fswiss\fcharset238\fprq2 Arial CE;}
{\f48\fswiss\fcharset204\fprq2 Arial Cyr;}{\f50\fswiss\fcharset161\fprq2 Arial Greek;}{\f51\fswiss\fcharset162\fprq2 Arial Tur;}{\f52\fbidi \fswiss\fcharset177\fprq2 Arial (Hebrew);}{\f53\fbidi \fswiss\fcharset178\fprq2 Arial (Arabic);}
{\f54\fswiss\fcharset186\fprq2 Arial Baltic;}{\f55\fswiss\fcharset163\fprq2 Arial (Vietnamese);}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;
\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{
\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Normal;}{\*\cs10 \additive \ssemihidden Default Paragraph Font;}{\*
\ts11\tsrowd\trftsWidthB3\trpaddl108\trpaddr108\trpaddfl3\trpaddft3\trpaddfb3\trpaddfr3\trcbpat1\trcfpat1\tscellwidthfts0\tsvertalt\tsbrdrt\tsbrdrl\tsbrdrb\tsbrdrr\tsbrdrdgl\tsbrdrdgr\tsbrdrh\tsbrdrv 
\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs20 \ltrch\fcs0 \fs20\lang1024\langfe1024\cgrid\langnp1024\langfenp1024 \snext11 \ssemihidden Normal Table;}{\s15\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 
\rtlch\fcs1 \af1\afs24\alang1025 \ltrch\fcs0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext15 Default;}}{\*\rsidtbl \rsid6045935\rsid6498123\rsid7622996\rsid9465567}{\*\generator Microsoft Word 10.0.2627;}{\info{\author Administrator}
{\operator Administrator}{\creatim\yr2004\mo11\dy16\hr15\min43}{\revtim\yr2004\mo11\dy16\hr15\min54}{\version4}{\edmins11}{\nofpages3}{\nofwords1415}{\nofchars8067}{\*\company Queens College}{\nofcharsws9464}{\vern16437}}\ltrsect 
\widowctrl\ftnbj\aenddoc\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\horzdoc\dghspace120\dgvspace120\dghorigin1701\dgvorigin1984\dghshow0\dgvshow3\jcompress\viewkind1\viewscale100\nolnhtadjtbl\rsidroot9465567 \fet0\ltrpar 
\sectd \ltrsect\sbknone\linex0\sectdefaultcl\sftnbj {\*\pnseclvl1\pnucrm\pnqc\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl2\pnucltr\pnqc\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl3\pndec\pnqc\pnstart1\pnindent720\pnhang {\pntxta .}}
{\*\pnseclvl4\pnlcltr\pnqc\pnstart1\pnindent720\pnhang {\pntxta )}}{\*\pnseclvl5\pndec\pnqc\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnqc\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl7
\pnlcrm\pnqc\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnqc\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnqc\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}\pard\plain \ltrpar
\s15\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af1\afs24\alang1025 \ltrch\fcs0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af1\afs28 \ltrch\fcs0 \b\fs28\insrsid6045935 
                                         
\par 
\par                                           Laboratory V
\par }{\rtlch\fcs1 \ab\af1\afs20 \ltrch\fcs0 \b\fs20\insrsid6045935                                                       CS-345, Fall 2004
\par                                                     Christopher Vickery
\par }{\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\insrsid6045935                                          }{\rtlch\fcs1 \af1 \ltrch\fcs0 \b\fs20\ul\insrsid6045935 Author:  Robert Edele  &  Frank Lam}{\rtlch\fcs1 \af1 \ltrch\fcs0 \insrsid6045935 
\par }{\rtlch\fcs1 \ab\af1\afs20 \ltrch\fcs0 \b\fs20\ul\cgrid0\insrsid6045935 
\par 
\par 
\par }{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\ul\insrsid6045935 Introduction:
\par }{\rtlch\fcs1 \ab\af1\afs20 \ltrch\fcs0 \b\fs20\ul\insrsid6045935 
\par }\pard \ltrpar\s15\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0\pararsid6498123 {\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\insrsid6045935 In this lab, we created video images in different ways. The }{\rtlch\fcs1 \af1 \ltrch\fcs0 \b\fs20\insrsid6045935 
first step }{\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\insrsid6045935 we created an image "on the fly" using PAL macros to tell our code which pixels needed to be drawn. The }{\rtlch\fcs1 \af1 \ltrch\fcs0 \b\fs20\insrsid6045935 second step }{\rtlch\fcs1 \af1 
\ltrch\fcs0 \fs20\insrsid6045935 we examined the values of some parameters. The }{\rtlch\fcs1 \af1 \ltrch\fcs0 \b\fs20\insrsid6045935 third step }{\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\insrsid6045935 we created an image}{\rtlch\fcs1 \af1 \ltrch\fcs0 
\fs20\insrsid6498123  "on the fly" and performed its }{\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\insrsid6045935 own synchronization with the video refresh cycle. The }{\rtlch\fcs1 \af1 \ltrch\fcs0 \b\fs20\insrsid6045935 last step }{\rtlch\fcs1 \af1 \ltrch\fcs0 
\fs20\insrsid6045935 we created an }{\rtlch\fcs1 \ab\af1\afs20 \ltrch\fcs0 \fs20\cgrid0\insrsid6045935\charrsid9465567 image by reading pixel values from RAM in real time, therefore we had to implement a }{\rtlch\fcs1 \af1\afs20 \ltrch\fcs0 
\fs20\insrsid6045935 frame buffer.}{\rtlch\fcs1 \ab\af1\afs20 \ltrch\fcs0 \fs20\cgrid0\insrsid6045935\charrsid6498123 
\par }\pard \ltrpar\s15\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af1\afs20 \ltrch\fcs0 \b\fs20\cgrid0\insrsid6045935 
\par }\pard \ltrpar\s15\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0\pararsid9465567 {\rtlch\fcs1 \ab\af1\afs20 \ltrch\fcs0 \fs20\cgrid0\insrsid6045935\charrsid9465567 
Lab activities included drawing an image using Pal Macros for synchronization, displaying video parameter values, drawing a test pattern by synchronizing with HBlank and drawing an image from a frame buffer.
\par }\pard \ltrpar\s15\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af1\afs20 \ltrch\fcs0 \b\fs20\cgrid0\insrsid6045935 
\par 
\par }{\rtlch\fcs1 \ab\af1\afs20 \ltrch\fcs0 \b\fs20\ul\cgrid0\insrsid6045935 
\par }{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\ul\insrsid6045935 Method
\par }{\rtlch\fcs1 \ab\af1\afs20 \ltrch\fcs0 \b\fs20\ul\insrsid6045935 
\par }{\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\insrsid6045935 In the }{\rtlch\fcs1 \af1 \ltrch\fcs0 \b\fs20\insrsid6045935 first step}{\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\insrsid6045935 , we created a workspace named }{\rtlch\fcs1 \af1 \ltrch\fcs0 
\b\fs20\insrsid6045935 "Laboratory V" }{\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\insrsid6045935 and created a project named}{\rtlch\fcs1 \af1 \ltrch\fcs0 \insrsid6045935 
\par }\pard \ltrpar\s15\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0\pararsid7622996 {\rtlch\fcs1 \af1 \ltrch\fcs0 \b\fs20\insrsid6045935 "Sevenseg  Display" }{\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\insrsid6045935 inside it. The source file name would be}{
\rtlch\fcs1 \af1 \ltrch\fcs0 \b\fs20\insrsid6045935  sevenseg.hcc}{\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\insrsid6045935 . We configured the settings as usual. For this part we were to draw
 the seven segment displays on the LCD screen instead of using real seven segment displays. First we used an array with 16 values each of 7 bits to store the values from 0,1,2.....F. }{\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\insrsid6498123 Then we set up an }{
\rtlch\fcs1 \af1 \ltrch\fcs0 \b\fs20\insrsid6498123 if }{\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\insrsid6498123 statement for the segment to decide whether the segment should be lit or unlit. }{\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\insrsid6045935 
We used absolute value functions to calculate if the length was within the segment length and if the width was also within the segment width in order to draw and made each segment looked like a diamond. We also had a main 
function to handle the keyboard input and another main function to handle video output. In the }{\rtlch\fcs1 \af1\afs20 \ltrch\fcs0 \fs20\insrsid6045935 main function for handling video output, we set the center points for each of the segments too.   }{
\rtlch\fcs1 \af1 \ltrch\fcs0 \insrsid6045935\charrsid7622996 
\par }\pard \ltrpar\s15\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af1\afs20 \ltrch\fcs0 \fs20\insrsid6045935 
\par 
\par }\pard \ltrpar\s15\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0\pararsid9465567 {\rtlch\fcs1 \ab\af1 \ltrch\fcs0 \fs20\cgrid0\insrsid6045935\charrsid7622996 In the }{\rtlch\fcs1 \af1 \ltrch\fcs0 \b\fs20\cgrid0\insrsid6045935\charrsid7622996 second step}
{\rtlch\fcs1 \ab\af1 \ltrch\fcs0 \fs20\cgrid0\insrsid6045935\charrsid7622996 , we created a project named "Parameters" inside the current workspace and included the pal_console.hch header and pal_console.hcl library file in our linker list.}{\rtlch\fcs1 
\ab\af1 \ltrch\fcs0 \fs20\cgrid0\insrsid9465567\charrsid7622996  }{\rtlch\fcs1 \ab\af1 \ltrch\fcs0 \fs20\cgrid0\insrsid6045935\charrsid7622996 
The source file is parameters.hcc. We configured the settings as usual. We used PAL macros to get the configuration values. We wrote
 the integers to the console by extracting the digits one at a time using %10 and /10, pushing them onto the stack and reading them off in reverse order. Then we set up several character strings for the parameters to describe each parameter and wrote the 
results to the console.}{\rtlch\fcs1 \ab\af1 \ltrch\fcs0 \cgrid0\insrsid6045935\charrsid7622996 
\par }\pard \ltrpar\s15\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af1\afs20 \ltrch\fcs0 \fs20\insrsid6045935 
\par 
\par }\pard \ltrpar\s15\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0\pararsid6498123 {\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\insrsid6045935 In the }{\rtlch\fcs1 \ab\af1 \ltrch\fcs0 \b\fs20\insrsid6045935\charrsid7622996 third step}{\rtlch\fcs1 \af1 \ltrch\fcs0 
\fs20\insrsid6045935 , we created a project named "}{\rtlch\fcs1 \af1 \ltrch\fcs0 \b\fs20\insrsid6045935 Unbuffered" }{\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\insrsid6045935 in the current workspace and using}{\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\insrsid6498123 
 }{\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\insrsid6045935 the source named }{\rtlch\fcs1 \af1 \ltrch\fcs0 \b\fs20\insrsid6045935 "unbuffered.hcc"}{\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\insrsid6045935 . We configured the settings as usual. We then drew a }{
\rtlch\fcs1 \af1\afs20 \ltrch\fcs0 \fs20\insrsid6045935 white pixel in the first column of each scan line and drew vertical bars of alternating colors across the remainder of each line using hsync and a scan line algorithm. }{\rtlch\fcs1 \af1 \ltrch\fcs0 
\insrsid6045935\charrsid6498123 
\par }\pard \ltrpar\s15\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af1\afs20 \ltrch\fcs0 \fs20\insrsid6045935 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \ltrpar\s15\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0\pararsid6498123 {\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\insrsid6045935 The }{\rtlch\fcs1 \af1 \ltrch\fcs0 \b\fs20\insrsid6045935 last step }{\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\insrsid6045935 
of the project was to use one of the RC200E's PL1 memory banks as a }{\rtlch\fcs1 \ab\af1\afs20 \ltrch\fcs0 \fs20\cgrid0\insrsid6045935\charrsid7622996 frame buffer, decide how to map pixel coordinates to memory addresses and write a test pattern 
into the ram. The test pattern was to consist of a one-pixel wide white border along all four edges of the visible part of the display. We then wrote code that continuously read from the frame buffer 
and drew the pixels to their proper locations on the screen}{\rtlch\fcs1 \af1\afs20 \ltrch\fcs0 \b\fs20\cgrid0\insrsid6045935 . }{\rtlch\fcs1 \af1 \ltrch\fcs0 \insrsid6045935\charrsid6498123 
\par }\pard \ltrpar\s15\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af1\afs20 \ltrch\fcs0 \b\fs20\cgrid0\insrsid6045935 
\par }{\rtlch\fcs1 \ab\af1 \ltrch\fcs0 \fs20\cgrid0\insrsid6045935\charrsid7622996 We had a main function to handle the video output. We set up the frame buffer by iterating through the first frame_size words of PL1 memory and wr
iting a COLOUR_WHITE if we were on or outside of a bounding rectangle consisting of the visible frame and the normal alternating bars otherwise. We synchronized to the screen by waiting for the end of the vertical retrace and waiting a whole frame less a 
small amount to account for delays in the pipeline and delays introduced by the remaining initialization code. Since we know that exactly frame_size clock cycles will pass between adjacent}{\rtlch\fcs1 \af1 \ltrch\fcs0 \b\fs20\cgrid0\insrsid6045935  }{
\rtlch\fcs1 \ab\af1 \ltrch\fcs0 \fs20\cgrid0\insrsid6045935\charrsid7622996 frames, we do not need to check for any more retraces, simplifying out timing code.}{\rtlch\fcs1 \ab\af1 \ltrch\fcs0 \cgrid0\insrsid6045935\charrsid7622996 
\par }{\rtlch\fcs1 \af1\afs20 \ltrch\fcs0 \fs20\insrsid6045935 
\par 
\par }{\rtlch\fcs1 \ab\af1\afs20 \ltrch\fcs0 \b\fs20\ul\insrsid6045935 
\par }{\rtlch\fcs1 \ab\af1 \ltrch\fcs0 \b\ul\insrsid6045935 Results:
\par }{\rtlch\fcs1 \ab\af1\afs20 \ltrch\fcs0 \b\fs20\ul\cgrid0\insrsid6045935 
\par }\pard \ltrpar\s15\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0\pararsid6498123 {\rtlch\fcs1 \af0 \ltrch\fcs0 \fs20\insrsid6045935 In the }{\rtlch\fcs1 \af0 \ltrch\fcs0 \b\fs20\insrsid6045935 first step}{\rtlch\fcs1 \af0 \ltrch\fcs0 
\fs20\insrsid6045935 , we found that the macro PalVideoOutWrite macro was quite useful whenever}{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid6498123  }{\rtlch\fcs1 \af1\afs20 \ltrch\fcs0 \fs20\insrsid6045935 
we wanted to draw a segment. The color output was 24 bit}{\rtlch\fcs1 \af1\afs20 \ltrch\fcs0 \fs20\insrsid6498123 . By pressing the keyboard, the }{\rtlch\fcs1 \af1\afs20 \ltrch\fcs0 \fs20\insrsid6045935 character in hexadecimal did successfully 
showed up on the console. Besides we found that}{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid6498123  }{\rtlch\fcs1 \af1\afs20 \ltrch\fcs0 \fs20\insrsid6045935 when we designed a segment as look like a diamond, it required less calculation and code.}{
\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid6045935\charrsid6498123 
\par }\pard \ltrpar\s15\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af1\afs20 \ltrch\fcs0 \fs20\insrsid6045935 The code ran smoothly and no errors were detected.  
\par 
\par 
\par }\pard \ltrpar\s15\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0\pararsid6045935 {\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\insrsid6045935 In the }{\rtlch\fcs1 \af1 \ltrch\fcs0 \b\fs20\insrsid6045935 second step}{\rtlch\fcs1 \af1 \ltrch\fcs0 
\fs20\insrsid6045935 , by choosing the right macros for each of the parameters, the values did }{\rtlch\fcs1 \ab\af1\afs20 \ltrch\fcs0 \fs20\cgrid0\insrsid6045935\charrsid7622996 
show up on the screen successfully. At first we were not quite sure about the correct macros for the width needed for a variable that ranges over all X coordinates on a scan line }{\rtlch\fcs1 \ab\af1 \ltrch\fcs0 
\fs20\cgrid0\insrsid6045935\charrsid7622996 and all Y coordinates on the display. We calculated it by t}{\rtlch\fcs1 \ab\af1 \ltrch\fcs0 \fs20\cgrid0\insrsid7622996 aking the ceiling of the log of }{\rtlch\fcs1 \ab\af1 \ltrch\fcs0 
\fs20\cgrid0\insrsid6045935\charrsid7622996 PalVideoOutGetVisibleXCT. The program ran smoothly and we did get what we wanted on the console. No errors were detected.}{\rtlch\fcs1 \af1 \ltrch\fcs0 \insrsid6045935\charrsid6045935 
\par }\pard \ltrpar\s15\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af1\afs20 \ltrch\fcs0 \fs20\insrsid6045935 
\par 
\par }{\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\insrsid6045935 In the }{\rtlch\fcs1 \af1 \ltrch\fcs0 \b\fs20\insrsid6045935 third step}{\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\insrsid6045935 , we drew alternating colors on a scan line by testing one bit position of}{
\rtlch\fcs1 \af1 \ltrch\fcs0 \insrsid6045935 
\par }{\rtlch\fcs1 \ab\af1\afs20 \ltrch\fcs0 \fs20\cgrid0\insrsid6045935\charrsid7622996 the register we used to keep track of the current position on the scan line. By testing the 
\par rightmost bit we found that the bars was one pixel wide and if we tested bit 1, the bars 
\par became 2 pixels wide. We settled on testing bit 3, giving us bars as wide as on the example graphic in the lab assignment. The program ran smoothly and no errors were detected.
\par 
\par }{\rtlch\fcs1 \af1\afs20 \ltrch\fcs0 \b\fs20\cgrid0\insrsid6045935 
\par }{\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\insrsid6045935 In the }{\rtlch\fcs1 \af1 \ltrch\fcs0 \b\fs20\insrsid6045935 last step}{\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\insrsid6045935 
, we successfully used a frame buffer and pipelining to get a one pixel wide border along the fou
r edges. Because we couldn't figure out how to detect the end of the vertical retrace ahead of time, we decided to only detect the end of the vertical retrace once and then go around a full frame minus a small offset. This small offset is very hard to cal
culate, as it is determined by our initialization code as well as the pipelining, and experimentation showed that an offset of -4 works. The program works smoothly and no errors were detected.}{\rtlch\fcs1 \af1 \ltrch\fcs0 \insrsid6045935 
\par }{\rtlch\fcs1 \af1\afs20 \ltrch\fcs0 \b\fs20\cgrid0\insrsid6045935 
\par 
\par 
\par }{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\ul\insrsid6045935 Discussion:
\par }{\rtlch\fcs1 \af1\afs20 \ltrch\fcs0 \fs20\insrsid6045935 
\par 
\par }{\rtlch\fcs1 \ab\af1\afs20 \ltrch\fcs0 \b\fs20\ul\insrsid6045935 
\par }{\rtlch\fcs1 \af1\afs20 \ltrch\fcs0 \fs20\insrsid6045935\charrsid7622996 Overall, after a slow start, we were very pleased at our results. Our biggest problems appeared in }{\rtlch\fcs1 \ab\af1\afs20 \ltrch\fcs0 \b\fs20\insrsid6045935\charrsid7622996 
part 1}{\rtlch\fcs1 \af1\afs20 \ltrch\fcs0 \fs20\insrsid6045935\charrsid7622996 
. We discovered an odd behavior of the hardware that is not replicated in the simulator. Unbalanced writes inclusive-or multiple conditional writes would cause the display to mess up, causing very 
odd and undesired behavior. Our early attempts at part 1 also created code that was so large after macro expansion that our souped-up computers with almost 4GB of (RAM + virtual memory) ran out of memory after fifteen minutes of swap thrashing. We managed
 to reduce the gate count to a more reasonable 300,000 and avoid the display bugs by rethinking our code and using a giant if}{\rtlch\fcs1 \ab\af1\afs20 \ltrch\fcs0 \b\fs20\insrsid6045935  }{\rtlch\fcs1 \af1\afs20 \ltrch\fcs0 
\fs20\insrsid6045935\charrsid7622996 statement to cover all the segments instead of a series of smaller if statements in parallel}{\rtlch\fcs1 \ab\af1\afs20 \ltrch\fcs0 \b\fs20\insrsid6045935 .
\par 
\par }{\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\cgrid0\insrsid6045935 We decided to go fancy and use hexagonal LEDs for our seven segment displays. The shape was defined as the intersection of the region between two parallel vertical }{\rtlch\fcs1 \af1 \ltrch\fcs0 
\fs20\cgrid0\insrsid6498123 or}{\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\cgrid0\insrsid6045935  horizontal lines spaced 40 apart and of a square rotated by PI/4 radians and with a diagonal length of 200. This shape prove
d to be almost as mathematically simple as a rectangle, being about 25% more complex than the simplest definition of a rectangle that we could thing of and simpler (at least in its mathematical representation) than the common 2-corner representation of a 
r
ectangle. Another wise move was to use the center of our LED to be its location, instead of either the two corner or the upper-left + length + width approaches commonly used. This made it much easier to figure out where everything went and allowed the use
 of more powerful algorithms relying on symmetry about the center which allowed us to make a fancier hexagonal LED for fairly little extra computational cost.}{\rtlch\fcs1 \af1 \ltrch\fcs0 \b\cgrid0\insrsid6045935 
\par }{\rtlch\fcs1 \ab\af1\afs20 \ltrch\fcs0 \b\fs20\insrsid6045935 
\par }{\rtlch\fcs1 \ab\af1 \ltrch\fcs0 \b\fs20\insrsid6045935\charrsid7622996 Part 2}{\rtlch\fcs1 \af1 \ltrch\fcs0 \fs20\insrsid6045935  proved little trouble to use. 10 of the 12 values just required that we read the PAL docum
entation carefully. For two of the values, we applied the ceiling of the log of the visible screen width and height to find out how large a variable needs to be to store a visible x or a visible y coordinate. We didn't realize that there was a built-in fu
nction to write an int to the console, and seeing that printf doesn't work, we implemented a stack based integer displayer. Though it was a little complex, we have plenty of experience writing such stuff and it wasn't a major hurdle.}{\rtlch\fcs1 \af1 
\ltrch\fcs0 \insrsid6045935 
\par }{\rtlch\fcs1 \ab\af1\afs20 \ltrch\fcs0 \b\fs20\cgrid0\insrsid6045935 
\par }{\rtlch\fcs1 \ab\af1\afs20 \ltrch\fcs0 \b\fs20\cgrid0\insrsid6045935\charrsid7622996 Part 3}{\rtlch\fcs1 \af1\afs20 \ltrch\fcs0 \fs20\cgrid0\insrsid6045935\charrsid7622996 
 proved quite simple. We followed the lab instructions very closely, and we got exactly the result we wanted.
\par 
\par }{\rtlch\fcs1 \ab\af1\afs20 \ltrch\fcs0 \b\fs20\cgrid0\insrsid6045935\charrsid7622996 Part 4}{\rtlch\fcs1 \af1\afs20 \ltrch\fcs0 \fs20\cgrid0\insrsid6045935\charrsid7622996 
 was coded fairly fast and without too much difficulty, but we did a lot more improvising than in part 3. We decided to use the whole
 frame and not just the visible part. This allowed us to synchronize the display code to the display without having to use the vertical retrace more than once. The reason for this was that we couldn't figure out how to know when we are 3 clock cycles befo
r
e the end of the vertical retrace. Counting out a whole frame and subtracting out a few (4, via experimentation) cycles successfully synchronized out output, and even though the implementation wasn't the most theoretically sound, we believe it is cross-pl
atform compatible in practice, as the size of a frame is determined using PAL macros and we believe that all hardware goes 1 pixel per clock cycle, with no pause when the end of the complete frame is reached.
\par 
\par Due to our lousy design which accesses the PL1RAM every single clock cycle, we didn't even make a serious attempt at the optional part of implementing 2 seven segment displays using the frame buffer.
\par }}