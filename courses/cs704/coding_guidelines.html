<HTML> <HEAD> <title> Coding Guidelines for CS-704 </title> <body>

<h2>Introduction</h2><p>This document gives the rules you are to
follow for all the programs you write for CS-704.  The basic rule
is that your code must be written so that it is correct, robust,
efficient, and easy to understand.  Most of the detailed specifications
given here apply to the "easy to understand" (Coding Style) criterion.</p>

<h2>Correctness, Robustness, Efficiency</h2><p>A correct program is one
that does what it is supposed to do when all inputs take on values
anywhere within their expected range.  A robust program is one that
behaves in a reasonable manner when it encounters input values that
are not within their normal range, including missing values.
Two reaonable things to do, depending on the severity of the error, are
to issue an error message and continue processing (recovery) or to
issue an error message and terminate (abort).  An efficient program is
one that performs only those computations necessary to accomplish the
work at hand.  Aside from the obvious advantage of executing quickly,
efficient code is typically much easier for someone else to read and
understand than code which performs extraneous operations, which the
reader has to understand in order to ignore!</p>

<h2>Coding Style</h2>
<p>Set up a separate project directory for each assignment, and put
only the files that actually are part of that assignment in the project
directory.  When you submit an assignment, send me an email telling me the path
to the project directory.  Do not modify any of the files in the project
directory once you submit an assignment; if you want to make changes,
make a copy of the files in another directory and make your changes there.</p>

<p>All code must compile with no remarks, no
warnings, and no errors when compiled with the <code>dn(0)</code>
option of iC-386.  (This option is "diagnostic level 0.")  It must also
bind with no warnings and no errors.</p>

<p>You must supply a function
prototype for every function you define, except <i>main()</i>.  The
function prototype must be in a header file if and only if the function
is defined in one source module and referenced from another module.  If
the function is referenced only from within the same module in which it
is defined and if the definition preceeds all references to the
function, the definition itself may be used as the prototype.</p>

<p>All source modules (.c files and .h files) must contain the
following sections in the order listed here:</p>

<h3>File Header</h3><p>The file must begin with a block of comments
that introduce the file, called the File Header.  The first line of
the file header is to
contain the name of the file.  Comments then give a Summary of the
file's contents.  If there is more than one function definition in the
file, provide a list of the Function Names with a phrase identifying
each.  This list must be in the same order as the sequence of function
definitions in the file.</p> <p>The Revision History for the file is
the section of the file header in which you list the changes made to
the file and the dates the changes were made.  For this course, the
revision history needs to include only those changes which have been
made since the file was last submitted as part of a project.  Since
most code you submit is handed in only once, the revision history will
typically say something like "Original Version."</p><p>Include the
Author's Name in the file header.  When more than one programmer works
on a file, the authors' names go in the revision history.  When there
is just one programmer, you can enter it in a separate subsection.</p>
Each of the items that is capitalized here ("Summary," "Function
Names," etc. should be used as a subheading for the corresponding
information in the file header.</p>

<h3>Include Files, Manifest Constants, and Macro Definitions</h3>
<p>All <code>#include</code> and <code>#define</code> statements
follow the File Header section.  Put <code>#define</code> statements
that are used in different source modules into a header file.  Although
ANSI C does not require it, putting a header file name in angle brackets
(< and >) conventionally means the header file is one that is supplied
with the compiler or part of a standard programming package that is
installed on the developement system.  Putting the name of the header
file in quotes conventionally means that the header file is specific to
the current project and is located in the project directory.</p>

<h3>Function Definitions</h3><p>Begin each function definition with a
Function Header, followed by the function definition itself.</p>

<h4>Function Header.</h4><p>A function header is a block of comments
that contains the following information in the order listed here:</p>

<dl>
<dt>Name<dd>The name of the function.
<dt>Summary<dd>A statement of the purpose of the function.  Use one
or more complete sentences.  Write in the present tense.
<dt>Arguments<dd>List the arguments to be passed to the function using
the names used in the function definition.  Give a phrase telling what
each is used for and any assumptions made about the valid range of values
the argument may meaningfully take.  If any arguments are modified or
are used as pointers to values that are modified, say so.
<dt>Return Value<dd>Tell what values are returned by the function.  If no
value is returned, say so.
<dt>Global Variables<dd>List any global variables that are referenced or
modified by the function.
<dt>Algorithm<dd>List the steps the function executes.  Use imperative
sentences.
</dl>

<h4>Function definition.</h4><p>Use ANSI function declarations such as
<code>void foo(int x) { ... }</code> instead of traditional definitions
such as <code> foo(x) int x; { ... }</code).</p>

<p> Use meaningful variable names
(Names like i, j, and k are OK for integers used to index arrays.).</p>

<p>Adopt
a consistent way of using capitalization and underscores in your variable
names.</p>

<p>In general, you do not need to comment your variable declarations.</p>

<p>
Use a consistent indentation style that shows the lexical structure of
your code.  Blank lines and other whitespace generally improve your
code's legibility, but make sure you don't use so large an indent amount
that lines get pushed off the right side of the page.  No code or comment
line should be more than 72 characters long.</p>

<p>The only comments you have
to write in your function definition are ones that correspond exactly to
the steps you listed in the Algorithm section of the Function Header.  These
comments go on lines by themselves just before the code that implements
each step of the algorithm.  Of course, you should add other comments if
a piece of code is difficult to understand, but try to write clear
code so the need for these extra comments is minimized.</p>

<h2>Notes</h2>

<p>This coding style discourages the use of many small functions
to implement a program, which is intentional.  First of all, small functions
generally are utilities.  In general, the standard C library provides all
the utility functions you need.  Be sure you are familiar with all the
utilities available to you, especially the string manipulation functions,
before you decide you need your own new one.  Writing code that re-implements
a standard function is very distracting to the people who look at your
code after you are finished with it, and should be avoided.  If you do
need to write a utility function, this coding style encourages you to
think about it carefully.  It is often the case that the same amount of
code can provide general utility instead of satisfying just a single need,
which increases the probablility that the function can be used in other
applications.  For this reason, utility functions should be in separate
source modules so they can be incorporated into other applications easily.</p>

<p>Believe it or not (and I know you don't), it really makes more sense
to write the comments before you write the code than the other way
around.  Listing the steps of the algorithm performed by a function and
then creating the sectional comments for each step means that writing
the code is just a matter of filling in the blanks.  It is much more
effective use of your time to think and then write code than its is to
debug a program
into existence.  On top of that, the world is full of programmers who
lament, "the program stopped working when I added the comments!"
Editing a file opens up the possibility of inadvertent changes, changes
that always seem particularly difficult to debug.</p>

<p>It could be argued that this style discourages program modularity by
increasing the overhead on the programmer for each new function defined.
Actually, good modularity demands that the interfaces to each module should
be carefully designed and that each module should be a self-contained
entity as much as possible.  The style presented here encourages this type
of modularity.</p>

<HR>
<Address>Christopher Vickery<BR>Queens College of CUNY</Address>
</BODY>
</HTML>
