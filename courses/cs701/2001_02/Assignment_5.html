<HTML><HEAD><TITLE>Assignment 5</TITLE>
<LINK REL=stylesheet HREF="http://babbage.cs.qc.edu/css/sans-serif_body.css"
MEDIA=screen>
</HEAD>
<BODY bgcolor=#FFFFFF>
<center>
<H1>Assignment 5</H1>
</center>

<H3>Introduction</H3>

This assignment explores some programming issues that are related to
implementing a more fully-featured Unix shell than you have coded so far
this semester.  For some of the features you will be implementing, you
are required to select a particular implementation method, specified in
this web page, even though there would be other ways to accomplish the
same functionality.  The idea is for you to gain experience with these
particular programming methodologies, not just to get your shell to
implement some feature.<p>

What follows is a description of a set of features and the methodology
you are to use to implement them, ordered as a sequence of development
steps.<p>

<H3>Due Date and Deliverables</H3>

The assignment is due by midnight May 22<sup>nd</sup>.  There will be no
extensions or late points for this project; you will simply have to
submit whatever you have completed by the due date.  This web page tells
you how much credit you can expect to get for the assignment depending
on how many steps you complete.<p>

Submit a tar file as an email attachment in the usual way.  Be sure to
include your name and student ID in the body of your email message.  The
tar file is to contain your project directory, which is to be empty
except for the RCS subdirectory and a text file named README.<p>

<center><table border=1 width="80%" cellpadding=5>
  <tr>
    <td>The README file is to tell what parts of the assignment you completed
and any optional or extra features you might have done.  But it is just
information for me, <i>not</i> documentation for the project.

</table></center>


<H3>Version 3.1: Low Level Reader</H3>

<center><i>You can receive a grade as high as 7.0/10 by completing this
version of the assignment satisfactorily.</i></center><p>

Start with Version 2 of your project. Fix any outstanding bugs, and
then change the program so it uses a "low level reader" instead of
<I>fgets()</I> to read command lines from stdin.  The low level reader
function must meet the following specifications:

<ul>
  <li>It must read input one byte at a time using the <I>read()</I>
  system call.
  <li>It must do all echoing of characters to the screen using
  the <I>write()</I> system call.
  <li>It must let the user erase characters that have been typed using
  the backspace (0x08), rubout (0x7F), or delete (0x1B 5B 33 7E) keys. 
  Be sure to handle erasures at the beginning of a line correctly by
  ignoring them instead of moving the cursor. 
  <li>It must recognize and not echo arrow keys typed by the user.
</ul>

Be sure to mention any of the following optional features in your
README file if you implement them:<p>

  <ul>
  
    <li><i>Optional:</i> Write a string, such as "&lt;up&gt;", to the
    screen when the user types an arrow key, but don't put any
    characters in the input buffer.

    <li><i>Optional:</i> Sound the terminal's "bell" by writing the
    string "\a" to the screen when the user tries to erase beyond the
    beginning of the input line or types an invalid escape sequence.

    <li><i>Optional:</i> Maintain a history of command lines, which the
    user can navigate using the up and down arrow keys.

    <li><i>Optional:</i> Let the user move back and forth within a
    command line using the left and right arrow keys, inserting and
    deleting characters in the middle of a line.

  </ul>

Note that both the arrow keys and the Delete key generate <i>escape
sequences</i>.  That is, a sequence of characters beginning with the
ASCII escape code, and ending when the escape sequence is "complete."
What it means for the sequence to be complete depends on the particular
sequence of characters received.<p>

<center><table border=1 width="80%" cellpadding=5>
  <tr>
    <td><b>Note:</b> Some terminals will not generate an escape
    sequence for the Delete key.  It depends on the software you are
    using to manage your terminal windows and how it is configured. 
    But you can test your code's functionality by typing the Delete key
    functionality as a sequence of four separate keystrokes:
    <code>&lt;Esc&gt;&nbsp;[&nbsp;3&nbsp;~</code><p>
    (This assumes your program does not use the technique described on
    page 353 of Stevens to differentiate between escape sequences
    generated by a single keystroke and the same sequence entered as a
    sequence of spearate keystrokes.)
</table></center><p>

It's not required, but I suggest that you handle escape sequences in a
general way, as follows:

<ul>

  <li>Set up an enum for the different escape sequences your program
  will recognize.  See the header file below to see how to do this.

  <li>Set up an array of structs that associates the values of the enum
  with the valid escape sequences your program will recognize.  For
  example:
  
  <pre>
      struct sequence_t
      {
        escape_t  code;
        char*     sequence;
        int       len;
      };
      sequence_t escapeTable[] =
      {
        { upArrow, "[A", 2 },
        <i>etc.</i>
  </pre>

  <li>Write a function that receives an fd number as an argument, and
  returns the enum value corresponding to the escape sequence it
  recognizes.  It reads characters from the fd (you could just use
  STDIN_FILENO instead of an fd parameter if you prefer) until it finds
  all the characters in one of its known sequences or has read enough
  characters to know that none of its known sequences was entered.Have
  an enum for "unrecognized," which the function returns if no escape
  sequence is recognized.

  <li>When the low level reader gets an escape character, it calls the
  function just described, and processes the value returned as
  appropriate.  See the [&nbsp;<a
  href="701_Lecture_26_files/rawreader.cc.html">current version of
  rawreader.cc</a>&nbsp;] for an example of code that calls a function
  (<i>recognize_escape()</i>) to process escape sequences.  Here's
  the header file that goes with that code:

  <pre>
  #ifndef __ESCAPES_H__
  #define __ESCAPES_H__

  //  Enum for recognized sequences
  //  ------------------------------------------------------------
  enum  escape_t
  {
    unrecognized = 0, upArrow, downArrow, leftArrow,
    rightArrow, deleteKey
  };

  //  Function prototype
  //  ------------------------------------------------------------
  escape_t recognize_escape(int fd );

  #endif
  </pre>

</ul>

<b>Controlling Terminal Settings</b><p>

There is one other issue you will have to deal with for this version of
the project.  When you use the <i>read()</i> system call, you bypass
the standard C library's routines for doing I/O.  For efficiency, the
standard library doesn't write everything to the screen as it the
program outputs it; it holds the output in a buffer until either the
buffer is full, the buffer is "flushed" (by calling <i>fflush()</i>),
or <u>a standard library routine reads from <i>stdin</i></u>.  This
last feature is there specifically to make sure that prompt strings
appear on the screen before the user has to respond to them.  But if you
call <i>read()</i> instead of, say, <i>fgets()</i>, you will lose this
automatic flushing of output when doing input.<p>

There are some other related problems that you need to deal with as
well.  For example, if you have the terminal in raw mode, any builtin
or external commands that try to do input or output will have problems
because the terminal settings are not right.  Worse yet, some shells
don't automatically put the terminal back into canonical mode when
commands finish, so when you exit <i>qsh</i>, you might find the
terminal failing to echo characters and possibly not recognizing what
you type. (<i>csh</i> has this problem.)<p>

All these issues can be handled in a simple way:  Have two termios
struct variables in your program, one containing the original terminal
settings in effect when your shell started, and the other one a
modified copy, as illustrated in <i>rawreader.cc</i>.  Instead of
calling <i>tcsetattr()</i> just once at the beginning of the program,
call it twice every time the program reads a command line from the
user: just before reading the line, call it to put the terminal into
"raw" mode, and once the command line has been read, call it again to
put the terminal back into "canonical" mode. This way, the program uses
raw mode only when it actually needs it, but when builtin or external
commands run, they get to use the terminal in canonical mode as they
expect to find it.  (But what happens if the user types Control-C while
typing a command?)<p>

<i>Optional:  If the user types Control-C while entering a command
line, whatever has been typed so far is discarded, and the program
issues another prompt.</i>  You would have to set up a signal handler
for SIGINT to do this.<p>

<h3>Version 3.2: Command Line Parser</h3>

<center><i>You can receive a grade as high as 8.0/10 by completing this
version of the assignment satisfactorily.</i></center><p>

Write a routine that breaks a command line returned by the low level
reader into an array of pointers to strings, just like the argument
vector you built using <i>strtok()</i> in previous versions of the
project.<p>

Do not do anything about aliases or environment variables yet, but do
write your parser so that it recognizes strings enclosed in single or
double quotation marks as (parts of) single tokens.  You do not have to
do anything about back quotes or backslashes.<p>

Note that the standard C library has two functions that will be
very useful for this task:<p>

<center><table border=1 width="80%" cellpadding=5>
  <tr>
    <td valign=top nowrap><i>strspn()</i>
    <td>Searches for the first occurrence of a character that is not
    included in another string.  Returns a count of the numbers of
    characters before finding the non-matching character.
  <tr>
    <td valign=top nowrap><i>strcspn()</i>
    <td>Performs the same search as <i>strspn()</i>, but looks for a
    character that <i>is</i> in the second string instead of not in it.
</table></center>
See the <i>man</i> pages for these functions for more information.<p>

<b>Example:</b>
<pre>
    <b>qsh></b> print "$Hello.   $? was the previou"s exit   '$code.'
    $Hello.   $? was the previous exit $code.
    <b>qsh></b>
</pre>

The parser would have returned an array of four tokens:
<ol>
    <li>print
    <li>$Hello.&nbsp;&nbsp;&nbsp;$? was the previous
    <li>exit
    <li>$code.
</ol>

<h3>Version 3.3: The <i>alias</i> Builtin Command</h3>

<center><i>You can receive a grade as high as 8.5/10 by completing this
version of the assignment satisfactorily.</i></center><p>

Implement a new builtin command named <i>alias</i>.  The first argument
(token) to this command is to be interpreted as an alias <u>name</u>,
and the last argument is to be interpreted as an alias <u>value</u>. 
Your program must also recognize a third argument, between the first and
last, which must be an equal sign ( "=" ).  <i>Optional: </i> Make the
second argument optional.<p>

The alias builtin command is to manage a list of aliases {<i>name,
value</i>} pairs.  In class, I recommended keeping it as a linked list
of C <code>structs</code>.  The user must be able to define new aliases
and to redefine existing aliases. <i>Optional: </i>An alias command with
a <u>name</u> but no <u>value</u> removes the named alias from the
list.<p>

If the user enters an alias command with no arguments, the command
prints the names and values of all the aliases currently defined, one
pair per line.<p>

<h3>Version 3.4: Alias Substitution</h3>

<center><i>You can receive a grade as high as 9.0/10 by completing this
version of the assignment satisfactorily.</i></center><p>

Modify the command line parser so that if the first token is the name of
an alias, the value of the alias will be substituted for the name in the
command line.  If there are spaces in the alias value, the parser must
parse the value and separate it into multiple tokens.<p>

<b>Example:</b>
<pre>
    <b>qsh></b> alias l = "/usr/bin/ls -lF"
    <b>qsh></b> l main.cc main.o
    [The <i>ls</i> command lists the two files using the -l and F options.]
    <b>qsh></b>
</pre>

<h3>Version 3.5: The <i>setenv</i> Builtin Command</h3>

<center><i>You can receive a grade as high as 9.5/10 by completing this
version of the assignment satisfactorily.</i></center><p>

Implement a new builtin command named <i>setenv</i>.  The first
argument (token) to this command is to be interpreted as an environment
variable <u>name</u>, and the last argument is to be interpreted as an
environment variable <u>value</u>.  Your program must also recognize a
third argument, between the first and last, which must be an equal sign
( "=" ).  <i>Optional: </i> Make the second argument optional.<p>

The setenv builtin command is to manage a list of {<i>name, value</i>}
environment variable pairs.  In class, I recommended keeping it as a
linked list of C <code>structs</code>.  The user must be able to define
new environment variables and to redefine existing environment
variables. <i>Optional: </i>A setenv command with a <u>name</u> but no
<u>value</u> removes the named environment variable from the list.<p>

If the user enters a setenv command with no arguments, the command
prints the names and values of all the environment variables currently
defined, one pair per line.<p>

<h3>Version 3.6: Use the Environment Variable List as the Third Argument
to <i>execve()</i></h3>

<center><i>You can receive a grade as high as 9.7/10 by completing this
version of the assignment satisfactorily.</i></center><p>

The way to test this step is to verify that the <i>printenv</i> external
command prints the same thing as the <i>setenv</i> builtin command with
no arguments.

<h3>Version 3.7: Variable Substitution</h3>

<center><i>You can receive a grade as high as 10.0/10 by completing this
version of the assignment satisfactorily.</i></center><p>

Modify the command line parser to that it substitutes the value of each
environment variable referenced in the command line. A variable
reference consists of a dollar sign ( "$" ) followed immediately by the
name of an environment variable.  For this assignment, variable
references will always end with a space, a tab, the end of the line, a
single, a double quote, an equal sign, a redirection symbol, or another
dollar sign (which begins another variable reference).<p>

<b>Notes:</b>
<ul>

  <li>Variable references inside single quotes are not to have their
  values substituted.
  
  <li>References to undefined variable names are to be replaced with
  nothing.  This is not an error, and no message should be printed.
  
  <li>The shell variable "?" is to be substituted by the exit code of the
  previous command unless it is inside single quotes, in which case it
  is to be left unchanged in the command line.

</ul>

<b>Extreme Example:</b>

<pre>
    <b>qsh></b> alias ? = 'print $?'
    <b>qsh></b> alias
    print $?
    <b>qsh></b> ? " was the previ$?us exit $code code."
    0 was the previ0us exit code.
</pre>

<HR></BODY></HTML>
